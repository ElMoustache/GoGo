#!/usr/bin/python3.1

class Command:
	def __init__(self):
		self.id = ''
		self.name = ''
		self.docstring = ''
		self.parameters = list()

class Parameter:
	def __init__(self):
		self.id = ''
		self.type = ''
		self.name = ''

def clean(commands):
	def get_type(paramID):
		if paramID == 0x00:
			return "int32_t"
		elif paramID == 0x01:
			return "uint32_t"
		elif paramID == 0x02:
			return "float"
		elif paramID == 0x03:
			return "bool"
		elif paramID == 0x04:
			return "const string&"
		elif paramID == 0x06:
			return "const array<float, 3>&"
		elif paramID == 0x07:
			return "const array<float, 3>&"
		elif paramID == 0x08:
			return "uint32_t"
		elif paramID == 0x09:
			return "uint64_t"
		elif paramID == 0x0A:
			return "tuple<shared_array<uint8_t> /* data */, size_t /* count */, size_t /* size */>"
		elif paramID == 0x0B:
			return "const array<uint16_t, 3>&"
		elif paramID == 0x0C:
			return "uint8_t"
		elif paramID == 0x0D:
			return "int16_t"
		elif paramID == 0x0E:
			return "uint16_t"
		else:
			return None
	
	to_drop = list()

	for c in commands:
		c.id = int(c.id, 16)
		c.name = ''.join([x for x in c.name if x != ' ']).replace('.', '_')
		# No docstring changes necessary.
		for p in c.parameters:
			p.type = get_type(p.id)
			if p.type == None:
				to_drop.append(c)
			p.name = ''.join([x for x in p.name if x != ' ']).replace('.', '_')

	return [c for c in commands if c not in to_drop]

def parse(p):
	c = list()
	for x in p:
		if x.find('Command ID = ') == 0:
			c.append(Command())
			c[-1].id = x[x.find(' = ') + 3:]
		elif x.find('Command = ') == 0:
			c[-1].name = x[x.find('"') + 1:-1]
		elif x.find('Command Help = ') == 0:
			c[-1].docstring = x[x.find('"') + 1:-1]
		elif x.find('    Parameter Type = ') == 0:
			c[-1].parameters.append(Parameter())
			c[-1].parameters[-1].id = int(x[x.find(' = ') + 3:], 16)
		elif x.find('    Parameter = ') == 0:
			c[-1].parameters[-1].name = x[x.find('"') + 1:-1]

	return clean(c)

def make_packet_registry_header_header():
	return """/*
 * NOTICE: Do not manually edit this file. It has been autogenerated by
 * protocol/parse.py. Any changes should me made there, instead of here.
 */
#pragma once
#include <string>
#include <cstddef>
#include <boost/signals2.hpp>
#include <boost/cstdint.hpp>
#include <boost/array.hpp>
#include <boost/tuple.hpp>
#include <boost/shared_array.hpp>

namespace packet {

// Handles the registration and dispatch to the various packet handlers
// around the nation.
class Registry
{
	using namespace boost;
	using namespace std;
public:
	PacketRegistry();

	void dispatch(uint16_t packetID,
	              const uint8_t* parameters,
		      uint16_t length);

	~PacketRegistry();

	// This signal is called when the parsing of a packet has failed. Do whatever you want in here.
	boost::signals2::signal<void (uint16_t /* packetID */,
	                              const uint8_t* /* rawParameters */,
	                              uint16_t /* length */)> OnFailedParse;"""

def make_packet_registry_header_footer():
	return "\n};"

def build_packet_registry_header(commands):
	f = open('include/net/PacketRegistry.h', 'w')

	print(make_packet_registry_header_header(), end='', file=f)
	
	for c in commands:
		print('\n\n\t// ', c.docstring, '\n', sep='', end='', file=f)
		print('\tboost::signals2::signal<void (', sep='',end='', file=f)
		for p in c.parameters:
			seperator = ''
			if p == c.parameters[0]:
				seperator = ''
			else:
				seperator = ', '

			print(seperator, p.type, ' /* ', p.name, ' */', sep='', end='', file=f)

		print(')> ', c.name, ';', sep='', end='', file=f)

	print(make_packet_registry_header_footer(), end='', file=f)

def make_packet_registry_cpp_header():
	return """/*
 * NOTICE: Do not manually edit this file. It has been autogenerated by
 * protocol/parse.py. Any changes should me made there, instead of here.
 */
#include <net/PacketRegistry.h>
#include <boost/format.hpp>

using namespace std;
using namespace boost;

// The following are implemented in security.cpp
// If they throw ANY exception, the packet's parsing will be broken,
// the packet will be dropped, and OnFailedParse will be signaled.
// The extraction method MUST modify *currentParam to point to the
// next element in the parameter string.
int32_t extract_int32(const uint8_t* paramStart, const uint8_t** currentParam, uint16_t packetLength);
uint32_t extract_uint32(const uint8_t* paramStart, const uint8_t** currentParam, uint16_t packetLength);
float extract_float(const uint8_t* paramStart, const uint8_t** currentParam, uint16_t packetLength);
bool extract_bool(const uint8_t* paramStart, const uint8_t** currentParam, uint16_t packetLength);
string extract_string(const uint8_t* paramStart, const uint8_t** currentParam, uint16_t packetLength);
array<float, 3> extract_position(const uint8_t* paramStart, const uint8_t** currentParam, uint16_t packetLength);
array<float, 3> extract_direction(const uint8_t* paramStart, const uint8_t** currentParam, uint16_t packetLength);
uint32_t extract_color(const uint8_t* paramStart, const uint8_t** currentParam, uint16_t packetLength);
uint64_t extract_MUID(const uint8_t* paramStart, const uint8_t** currentParam, uint16_t packetLength);
tuple<shared_array<uint8_t> /* data */, size_t /* count */, size_t /* size */>
extract_blob(const uint8_t* paramStart, const uint8_t** currentParam, uint16_t packetLength);
array<uint16_t, 3> extract_vector(const uint8_t* paramStart, const uint8_t** currentParam, uint16_t packetLength);
uint8_t extract_uint8(const uint8_t* paramStart, const uint8_t** currentParam, uint16_t packetLength);
int16_t extract_int16(const uint8_t* paramStart, const uint8_t** currentParam, uint16_t packetLength);
uint16_t extract_uint16(const uint8_t* paramStart, const uint8_t**currentParam, uint16_t packetLength);

namespace packet {

PacketRegistry::PacketRegistry()
{
}

PacketRegistry::~PacketRegistry()
{
}

void PacketRegistry::dispatch(uint16_t packetID,
                              const uint8_t* parameters,
                              uint16_t length)
{
	const uint8_t* paramPtr = parameters;

	try {
		switch(packetID)
		{
"""

# Just accept it. LOL.
def make_packet_registry_cpp_footer():
	return "\t\t}\n\t} catch(...) {\n\t\t\tthis->OnFailedParse(packetID, parameters, length);\n\t}\n}\n\n}"

def make_case(command):
	extractorMap = {
		0x00 : ("int32_t", "extract_int32"),
		0x01 : ("uint32_t", "extract_uint32"),
		0x02 : ("float", "extract_float"),
		0x03 : ("bool", "extract_bool"),
		0x04 : ("string", "extract_string"),
		0x06 : ("array<float, 3>", "extract_position"),
		0x07 : ("array<float, 3>", "extract_direction"),
		0x08 : ("uint32_t", "extract_color"),
		0x09 : ("uint64_t", "extract_MUID"),
		0x0A : ("tuple<shared_arary<uint8_t>, size_t, size_t>", "extract_blob"),
		0x0B : ("array<uint16_t, 3>", "extract_vector"),
		0x0C : ("uint8_t", "extract_uint8"),
		0x0D : ("int16_t", "extract_int16"),
		0x0E : ("uint16_t", "extract_uint16")
	}

	ret = ''.join(['\t\tcase ::', command.name, '::packetID:\n'])

	for (p, i) in zip(command.parameters, range(9999999)):
		(type, func) = extractorMap[p.id]
		ret = ''.join([ret, '\t\t\t', type, ' p', str(i), ' = ', func, '(parameters, &paramPtr, length);\n'])

	ret = ''.join([ret, '\t\t\tthis->', command.name, '('])

	for (p, i) in zip(command.parameters, range(9999999)):
		sep = ''
		if i == 0:
			sep = ''
		else:
			sep = ', '

		ret = ''.join([ret, sep, 'p', str(i)])

	ret = ''.join([ret, ');\n\t\t\tbreak;\n'])

	return ret

def build_packet_registry_cpp(commands):
	f = open('net/src/PacketRegistry.cpp', 'w')

	print(make_packet_registry_cpp_header(), end='', file=f)

	for c in commands:
		end = ''
		if c == commands[-1]:
			end = ''
		else:
			end = '\n'
		print(make_case(c), end=end, file=f);
	
	print(make_packet_registry_cpp_footer(), end='', file=f)

def make_all_packet_types_header_header():
	return """/*
 * NOTICE: Do not manually edit this file. It has been autogenerated by
 * protocol/parse.py. Any changes should me made there, instead of here.
 */
#pragma once"""


def build_all_packet_types_header(commands):
	f = open('include/net/packet_types/all', 'w')

	print(make_all_packet_types_header_header(), end='', file=f)

	for c in commands:
		print('\n#include "', c.name, '.h"', sep='', end='', file=f)

commands = list()

commands = parse([x[:-1] for x in open('protocol.txt').readlines()])
build_packet_registry_header(commands)
build_packet_registry_cpp(commands)
build_all_packet_types_header(commands)
